https://github.com/Z3Prover/z3/issues/6902
Index: src/util/memory_manager.cpp
--- src/util/memory_manager.cpp.orig
+++ src/util/memory_manager.cpp
@@ -29,6 +29,8 @@ Copyright (c) 2015 Microsoft Corporation
 # define malloc_usable_size _msize
 #endif
 
+#define SIZE_T_ALIGN 2
+
 // The following two function are automatically generated by the mk_make.py script.
 // The script collects ADD_INITIALIZER and ADD_FINALIZER commands in the .h files.
 // For example, rational.h contains
@@ -278,7 +280,7 @@ void memory::deallocate(void * p) {
     size_t sz      = malloc_usable_size(p);
     void * real_p  = p;
 #else
-    size_t * sz_p  = reinterpret_cast<size_t*>(p) - 1;
+    size_t * sz_p  = reinterpret_cast<size_t*>(p) - SIZE_T_ALIGN;
     size_t sz      = *sz_p;
     void * real_p  = reinterpret_cast<void*>(sz_p);
 #endif
@@ -291,7 +293,7 @@ void memory::deallocate(void * p) {
 
 void * memory::allocate(size_t s) {
 #ifndef HAS_MALLOC_USABLE_SIZE
-    s = s + sizeof(size_t); // we allocate an extra field!
+    s = s + SIZE_T_ALIGN * sizeof(size_t); // we allocate an extra field!
 #endif
     g_memory_thread_alloc_size += s;
     g_memory_thread_alloc_count += 1;
@@ -308,7 +310,7 @@ void * memory::allocate(size_t s) {
     return r;
 #else
     *(static_cast<size_t*>(r)) = s;
-    return static_cast<size_t*>(r) + 1; // we return a pointer to the location after the extra field
+    return static_cast<size_t*>(r) + SIZE_T_ALIGN; // we return a pointer to the location after the extra field
 #endif
 }
 
@@ -320,10 +322,10 @@ void* memory::reallocate(void *p, size_t s) {
     if (sz >= s)
         return p;
 #else
-    size_t *sz_p = reinterpret_cast<size_t*>(p)-1;
+    size_t *sz_p = reinterpret_cast<size_t*>(p)-SIZE_T_ALIGN;
     size_t sz = *sz_p;
     void *real_p = reinterpret_cast<void*>(sz_p);
-    s = s + sizeof(size_t); // we allocate an extra field!
+    s = s + SIZE_T_ALIGN * sizeof(size_t); // we allocate an extra field!
 #endif
     g_memory_thread_alloc_size += s - sz;
     g_memory_thread_alloc_count += 1;
@@ -341,7 +343,7 @@ void* memory::reallocate(void *p, size_t s) {
     return r;
 #else
     *(static_cast<size_t*>(r)) = s;
-    return static_cast<size_t*>(r) + 1; // we return a pointer to the location after the extra field
+    return static_cast<size_t*>(r) + SIZE_T_ALIGN; // we return a pointer to the location after the extra field
 #endif
 }
 
@@ -358,7 +360,7 @@ void memory::deallocate(void * p) {
     size_t sz      = malloc_usable_size(p);
     void * real_p  = p;
 #else
-    size_t * sz_p  = reinterpret_cast<size_t*>(p) - 1;
+    size_t * sz_p  = reinterpret_cast<size_t*>(p) - SIZE_T_ALIGN;
     size_t sz      = *sz_p;
     void * real_p  = reinterpret_cast<void*>(sz_p);
 #endif
@@ -368,7 +370,7 @@ void memory::deallocate(void * p) {
 
 void * memory::allocate(size_t s) {
 #ifndef HAS_MALLOC_USABLE_SIZE
-    s = s + sizeof(size_t); // we allocate an extra field!
+    s = s + SIZE_T_ALIGN * sizeof(size_t); // we allocate an extra field!
 #endif
     g_memory_alloc_size += s;
     g_memory_alloc_count += 1;
@@ -389,7 +391,7 @@ void * memory::allocate(size_t s) {
     return r;
 #else
     *(static_cast<size_t*>(r)) = s;
-    return static_cast<size_t*>(r) + 1; // we return a pointer to the location after the extra field
+    return static_cast<size_t*>(r) + SIZE_T_ALIGN; // we return a pointer to the location after the extra field
 #endif
 }
 
@@ -401,10 +403,10 @@ void* memory::reallocate(void *p, size_t s) {
     if (sz >= s)
         return p;
 #else
-    size_t * sz_p  = reinterpret_cast<size_t*>(p) - 1;
+    size_t * sz_p  = reinterpret_cast<size_t*>(p) - SIZE_T_ALIGN;
     size_t sz      = *sz_p;
     void * real_p  = reinterpret_cast<void*>(sz_p);
-    s = s + sizeof(size_t); // we allocate an extra field!
+    s = s + SIZE_T_ALIGN * sizeof(size_t); // we allocate an extra field!
 #endif
     g_memory_alloc_size += s - sz;
     g_memory_alloc_count += 1;
@@ -425,7 +427,7 @@ void* memory::reallocate(void *p, size_t s) {
     return r;
 #else
     *(static_cast<size_t*>(r)) = s;
-    return static_cast<size_t*>(r) + 1; // we return a pointer to the location after the extra field
+    return static_cast<size_t*>(r) + SIZE_T_ALIGN; // we return a pointer to the location after the extra field
 #endif
 }
  
