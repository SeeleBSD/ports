Index: lld/ELF/Symbols.h
--- lld/ELF/Symbols.h.orig
+++ lld/ELF/Symbols.h
@@ -161,6 +161,9 @@ class Symbol { (public)
   // True if the name contains '@'.
   uint8_t hasVersionSuffix : 1;
 
+  // True if the .gnu.warning.SYMBOL is set for the symbol
+  uint8_t gwarn : 1;
+
   // Symbol visibility. This is the computed minimum visibility of all
   // observed non-DSO symbols.
   uint8_t visibility() const { return stOther & 3; }
@@ -255,7 +258,7 @@ class Symbol { (public)
          uint8_t stOther, uint8_t type)
       : file(file), nameData(name.data()), nameSize(name.size()), type(type),
         binding(binding), stOther(stOther), symbolKind(k),
-        exportDynamic(false) {}
+        exportDynamic(false), gwarn(false) {}
 
   void overwrite(Symbol &sym, Kind k) const {
     if (sym.traced)
@@ -292,6 +295,9 @@ class Symbol { (public)
   // True if defined in a DSO as protected visibility.
   uint8_t dsoProtected : 1;
 
+  // True if targeted by a range extension thunk.
+  uint8_t thunkAccessed : 1;
+
   // Temporary flags used to communicate which symbol entries need PLT and GOT
   // entries during postScanRelocations();
   std::atomic<uint16_t> flags;
@@ -490,6 +496,9 @@ struct ElfSym {
   // __bss_start
   static Defined *bss;
 
+  // __data_start
+  static Defined *data;
+
   // etext and _etext
   static Defined *etext1;
   static Defined *etext2;
@@ -546,6 +555,8 @@ void reportDuplicate(const Symbol &sym, const InputFil
                      InputSectionBase *errSec, uint64_t errOffset);
 void maybeWarnUnorderableSymbol(const Symbol *sym);
 bool computeIsPreemptible(const Symbol &sym);
+
+extern llvm::DenseMap<StringRef, StringRef> gnuWarnings;
 
 } // namespace elf
 } // namespace lld
